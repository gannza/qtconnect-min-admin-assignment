const ValidationResult = require('./ValidationResult');

/**
 * Abstract base validator class 
 */
class BaseValidator {
  constructor() {
    this.rules = new Map();
  }

  /**
   * Add a validation rule for a specific field
   * @param {string} field - The field name
   * @param {ValidationRule} rule - The validation rule
   */
  addRule(field, rule) {
    if (!this.rules.has(field)) {
      this.rules.set(field, []);
    }
    this.rules.get(field).push(rule);
  }

  /**
   * Add multiple rules for a specific field
   * @param {string} field - The field name
   * @param {Array<ValidationRule>} rules - Array of validation rules
   */
  addRules(field, rules) {
    if (!this.rules.has(field)) {
      this.rules.set(field, []);
    }
    this.rules.get(field).push(...rules);
  }

  /**
   * Validate the given data against all defined rules
   * @param {Object} data - The data to validate
   * @returns {Promise<ValidationResult>}
   */
  async validate(data) {
    const result = new ValidationResult();

    // Validate each field with its rules
    for (const [field, rules] of this.rules) {
      const value = data[field];

      for (const rule of rules) {
        try {
          const ruleResult = await rule.validate(value, field, data);
          result.merge(ruleResult);
        } catch (error) {
          result.addError(field, `Validation error: ${error.message}`, rule.getName());
        }
      }
    }

    return result;
  }

  /**
   * Validate only specific fields
   * @param {Object} data - The data to validate
   * @param {Array<string>} fields - Array of field names to validate
   * @returns {Promise<ValidationResult>}
   */
  async validateFields(data, fields) {
    const result = new ValidationResult();

    for (const field of fields) {
      if (this.rules.has(field)) {
        const value = data[field];
        const rules = this.rules.get(field);

        for (const rule of rules) {
          try {
            const ruleResult = await rule.validate(value, field, data);
            result.merge(ruleResult);
          } catch (error) {
            result.addError(field, `Validation error: ${error.message}`, rule.getName());
          }
        }
      }
    }

    return result;
  }

  /**
   * Get all validation rules for a specific field
   * @param {string} field - The field name
   * @returns {Array<ValidationRule>}
   */
  getRulesForField(field) {
    return this.rules.get(field) || [];
  }

  /**
   * Check if a field has validation rules
   * @param {string} field - The field name
   * @returns {boolean}
   */
  hasRulesForField(field) {
    return this.rules.has(field) && this.rules.get(field).length > 0;
  }

  /**
   * Remove all rules for a specific field
   * @param {string} field - The field name
   */
  clearRulesForField(field) {
    this.rules.delete(field);
  }

  /**
   * Clear all validation rules
   */
  clearAllRules() {
    this.rules.clear();
  }

  /**
   * Get all fields that have validation rules
   * @returns {Array<string>}
   */
  getValidatedFields() {
    return Array.from(this.rules.keys());
  }

  /**
   * Create a validation result with custom errors
   * @param {Array} errors - Array of error objects
   * @returns {ValidationResult}
   */
  createErrorResult(errors) {
    return ValidationResult.failure(errors);
  }

  /**
   * Create a successful validation result
   * @returns {ValidationResult}
   */
  createSuccessResult() {
    return ValidationResult.success();
  }
}

module.exports = BaseValidator;
